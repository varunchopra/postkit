-- =============================================================================
-- SESSION MANAGEMENT FOR POSTKIT/AUTHN
-- =============================================================================
-- Sessions represent authenticated login state. Token is generated by caller,
-- hashed with SHA-256, and stored. Validation is a hot path - optimized.
-- =============================================================================


-- =============================================================================
-- CREATE SESSION
-- =============================================================================
CREATE OR REPLACE FUNCTION authn.create_session(
    p_user_id uuid,
    p_token_hash text,
    p_expires_in interval DEFAULT NULL,
    p_ip_address inet DEFAULT NULL,
    p_user_agent text DEFAULT NULL,
    p_namespace text DEFAULT 'default'
)
RETURNS uuid
AS $$
DECLARE
    v_session_id uuid;
    v_expires_at timestamptz;
BEGIN
    PERFORM authn._validate_hash(p_token_hash, 'token_hash', false);
    PERFORM authn._validate_namespace(p_namespace);

    -- Use default duration if not specified
    v_expires_at := now() + COALESCE(p_expires_in, authn._session_duration());

    INSERT INTO authn.sessions (
        namespace, user_id, token_hash, expires_at, ip_address, user_agent
    ) VALUES (
        p_namespace, p_user_id, p_token_hash, v_expires_at, p_ip_address, p_user_agent
    )
    RETURNING id INTO v_session_id;

    -- Audit log (never log token_hash!)
    PERFORM authn._log_event(
        'session_created', p_namespace, 'session', v_session_id::text,
        NULL,
        jsonb_build_object('user_id', p_user_id, 'expires_at', v_expires_at),
        p_ip_address
    );

    RETURN v_session_id;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER SET search_path = authn, pg_temp;

COMMENT ON FUNCTION authn.create_session(uuid, text, interval, inet, text, text) IS
'Creates a new session. Token hash is caller-provided SHA-256 of the session token.';


-- =============================================================================
-- VALIDATE SESSION
-- =============================================================================
-- HOT PATH: No audit logging here - would bloat logs.
-- Returns user info if session is valid, empty otherwise.
CREATE OR REPLACE FUNCTION authn.validate_session(
    p_token_hash text,
    p_namespace text DEFAULT 'default'
)
RETURNS TABLE(
    user_id uuid,
    email text,
    session_id uuid
)
AS $$
BEGIN
    PERFORM authn._validate_hash(p_token_hash, 'token_hash', false);
    PERFORM authn._validate_namespace(p_namespace);

    RETURN QUERY
    SELECT
        u.id AS user_id,
        u.email,
        s.id AS session_id
    FROM authn.sessions s
    JOIN authn.users u ON u.id = s.user_id AND u.namespace = s.namespace
    WHERE s.token_hash = p_token_hash
      AND s.namespace = p_namespace
      AND s.revoked_at IS NULL
      AND s.expires_at > now()
      AND u.disabled_at IS NULL;
END;
$$ LANGUAGE plpgsql STABLE SECURITY INVOKER SET search_path = authn, pg_temp;

COMMENT ON FUNCTION authn.validate_session(text, text) IS
'Validates a session token and returns user info if valid.
Returns empty if: expired, revoked, or user disabled.
Does NOT log for performance (hot path).';


-- =============================================================================
-- EXTEND SESSION
-- =============================================================================
CREATE OR REPLACE FUNCTION authn.extend_session(
    p_token_hash text,
    p_extend_by interval DEFAULT NULL,
    p_namespace text DEFAULT 'default'
)
RETURNS timestamptz
AS $$
DECLARE
    v_new_expires_at timestamptz;
BEGIN
    PERFORM authn._validate_hash(p_token_hash, 'token_hash', false);
    PERFORM authn._validate_namespace(p_namespace);

    v_new_expires_at := now() + COALESCE(p_extend_by, authn._session_duration());

    UPDATE authn.sessions
    SET expires_at = v_new_expires_at
    WHERE token_hash = p_token_hash
      AND namespace = p_namespace
      AND revoked_at IS NULL
      AND expires_at > now();

    IF NOT FOUND THEN
        RETURN NULL;
    END IF;

    RETURN v_new_expires_at;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER SET search_path = authn, pg_temp;

COMMENT ON FUNCTION authn.extend_session(text, interval, text) IS
'Extends session expiry. Returns new expires_at or NULL if session invalid.';


-- =============================================================================
-- REVOKE SESSION
-- =============================================================================
CREATE OR REPLACE FUNCTION authn.revoke_session(
    p_token_hash text,
    p_namespace text DEFAULT 'default'
)
RETURNS boolean
AS $$
DECLARE
    v_session_id uuid;
    v_user_id uuid;
    v_count int;
BEGIN
    PERFORM authn._validate_hash(p_token_hash, 'token_hash', false);
    PERFORM authn._validate_namespace(p_namespace);

    UPDATE authn.sessions
    SET revoked_at = now()
    WHERE token_hash = p_token_hash
      AND namespace = p_namespace
      AND revoked_at IS NULL
    RETURNING id, user_id INTO v_session_id, v_user_id;

    GET DIAGNOSTICS v_count = ROW_COUNT;

    IF v_count > 0 THEN
        -- Audit log
        PERFORM authn._log_event(
            'session_revoked', p_namespace, 'session', v_session_id::text,
            NULL, jsonb_build_object('user_id', v_user_id)
        );
    END IF;

    RETURN v_count > 0;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER SET search_path = authn, pg_temp;

COMMENT ON FUNCTION authn.revoke_session(text, text) IS
'Revokes a session by token hash.';


-- =============================================================================
-- REVOKE ALL SESSIONS
-- =============================================================================
CREATE OR REPLACE FUNCTION authn.revoke_all_sessions(
    p_user_id uuid,
    p_namespace text DEFAULT 'default'
)
RETURNS int
AS $$
DECLARE
    v_count int;
BEGIN
    PERFORM authn._validate_namespace(p_namespace);

    UPDATE authn.sessions
    SET revoked_at = now()
    WHERE user_id = p_user_id
      AND namespace = p_namespace
      AND revoked_at IS NULL;

    GET DIAGNOSTICS v_count = ROW_COUNT;

    IF v_count > 0 THEN
        -- Audit log
        PERFORM authn._log_event(
            'sessions_revoked_all', p_namespace, 'user', p_user_id::text,
            NULL, jsonb_build_object('sessions_revoked', v_count)
        );
    END IF;

    RETURN v_count;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER SET search_path = authn, pg_temp;

COMMENT ON FUNCTION authn.revoke_all_sessions(uuid, text) IS
'Revokes all active sessions for a user. Returns count revoked.';


-- =============================================================================
-- LIST SESSIONS
-- =============================================================================
CREATE OR REPLACE FUNCTION authn.list_sessions(
    p_user_id uuid,
    p_namespace text DEFAULT 'default'
)
RETURNS TABLE(
    id uuid,
    created_at timestamptz,
    expires_at timestamptz,
    ip_address inet,
    user_agent text
)
AS $$
BEGIN
    PERFORM authn._validate_namespace(p_namespace);
    PERFORM authn._warn_namespace_mismatch(p_namespace);

    RETURN QUERY
    SELECT
        s.id,
        s.created_at,
        s.expires_at,
        s.ip_address,
        s.user_agent
    FROM authn.sessions s
    WHERE s.user_id = p_user_id
      AND s.namespace = p_namespace
      AND s.revoked_at IS NULL
      AND s.expires_at > now()
    ORDER BY s.created_at DESC;
END;
$$ LANGUAGE plpgsql STABLE SECURITY INVOKER SET search_path = authn, pg_temp;

COMMENT ON FUNCTION authn.list_sessions(uuid, text) IS
'Lists active sessions for a user. Does NOT return token_hash.';
